From be5ec6fbb52964bd5f2e9e3261d520e73b2b20ea Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Fri, 17 May 2024 19:43:49 -0500
Subject: [PATCH 01/19] Add touch-gestures to open up Steam menus

---
 src/main.cpp     |  5 +++++
 src/wlserver.cpp | 28 ++++++++++++++++++++++++++++
 src/wlserver.hpp |  1 +
 3 files changed, 34 insertions(+)

diff --git a/src/main.cpp b/src/main.cpp
index 9dff5c4..6912b50 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -110,6 +110,8 @@ const struct option *gamescope_options = (struct option[]){
 
 	// wlserver options
 	{ "xwayland-count", required_argument, nullptr, 0 },
+	{ "touch-gestures", no_argument, nullptr, 0 },
+
 
 	// steamcompmgr options
 	{ "cursor", required_argument, nullptr, 0 },
@@ -187,6 +189,7 @@ const char usage[] =
 	"  -T, --stats-path               write statistics to path\n"
 	"  -C, --hide-cursor-delay        hide cursor image after delay\n"
 	"  -e, --steam                    enable Steam integration\n"
+	"  --touch-gestures               enable touch gestures for Steam menus\n"
 	"  --xwayland-count               create N xwayland servers\n"
 	"  --prefer-vk-device             prefer Vulkan device for compositing (ex: 1002:7300)\n"
 	"  --force-orientation            rotate the internal display (left, right, normal, upsidedown)\n"
@@ -733,6 +736,8 @@ int main(int argc, char **argv)
 					g_bDebugLayers = true;
 				} else if (strcmp(opt_name, "disable-color-management") == 0) {
 					g_bForceDisableColorMgmt = true;
+				} else if (strcmp(opt_name, "touch-gestures") == 0) {
+					cv_touch_gestures = true;
 				} else if (strcmp(opt_name, "xwayland-count") == 0) {
 					g_nXWaylandCount = atoi( optarg );
 				} else if (strcmp(opt_name, "composite-debug") == 0) {
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index 78a86ee..ceeef24 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -82,6 +82,7 @@ using namespace std::literals;
 extern gamescope::ConVar<bool> cv_drm_debug_disable_explicit_sync;
 
 //#define GAMESCOPE_SWAPCHAIN_DEBUG
+gamescope::ConVar<bool> cv_touch_gestures( "enable_touch_gestures", false, "Enable/Disable the usage of touch gestures" );
 
 struct wlserver_t wlserver = {
 	.touch_down_ids = {}
@@ -2537,6 +2538,33 @@ void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool
 
 			if ( bAlwaysWarpCursor )
 				wlserver_mousewarp( tx, ty, time, false );
+
+			if (cv_touch_gestures) {
+				bool start_gesture = false;
+
+				// Round the x-coordinate to the nearest whole number
+				uint32_t roundedCursorX = static_cast<int>(std::round(tx));
+				// Grab 2% of the display to be used for the edge range
+				uint32_t edge_range = static_cast<uint32_t>(g_nOutputWidth * 0.02);
+
+				// Determine if the gesture should start
+				if (roundedCursorX <= edge_range || roundedCursorX >= g_nOutputWidth - edge_range) {
+					start_gesture = true;
+				}
+
+				// Handle Home gesture
+				if (start_gesture && roundedCursorX >= edge_range) {
+					wlserver_open_steam_menu(0);
+					start_gesture = false;
+				}
+
+				// Handle QAM gesture
+				if (start_gesture && roundedCursorX >= g_nOutputWidth - edge_range && roundedCursorX <= g_nOutputWidth) {
+					wlserver_open_steam_menu(1);
+					start_gesture = false;
+				}
+			}
+
 		}
 		else if ( eMode == gamescope::TouchClickModes::Disabled )
 		{
diff --git a/src/wlserver.hpp b/src/wlserver.hpp
index 0569472..3304c18 100644
--- a/src/wlserver.hpp
+++ b/src/wlserver.hpp
@@ -272,6 +272,7 @@ void wlserver_x11_surface_info_finish( struct wlserver_x11_surface_info *surf );
 void wlserver_set_xwayland_server_mode( size_t idx, int w, int h, int refresh );
 
 extern std::atomic<bool> g_bPendingTouchMovement;
+extern gamescope::ConVar<bool> cv_touch_gestures;
 
 void wlserver_open_steam_menu( bool qam );
 
-- 
2.47.1


From a90799dbad065c6933796f1708b245b561924159 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Wed, 26 Jul 2023 20:46:29 -0500
Subject: [PATCH 02/19] Add force external orientation.

Co-authored-by: Bouke Sybren Haarsma <boukehaarsma23@gmail.com>
---
 src/Backends/DRMBackend.cpp |  5 +++++
 src/main.cpp                | 25 ++++++++++++++++++++++++-
 src/main.hpp                |  1 +
 src/wlserver.cpp            | 23 +++++++++++++++++++++++
 4 files changed, 53 insertions(+), 1 deletion(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 3a996af..6bc64fa 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -532,6 +532,7 @@ bool g_bSupportsSyncObjs = false;
 
 extern gamescope::GamescopeModeGeneration g_eGamescopeModeGeneration;
 extern GamescopePanelOrientation g_DesiredInternalOrientation;
+extern GamescopePanelOrientation g_DesiredExternalOrientation;
 
 extern bool g_bForceDisableColorMgmt;
 
@@ -2026,6 +2027,10 @@ namespace gamescope
 		{
 			m_ChosenOrientation = g_DesiredInternalOrientation;
 		}
+		else if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO )
+		{
+			m_ChosenOrientation = g_DesiredExternalOrientation;
+		}
 		else
 		{
 			if ( this->GetProperties().panel_orientation )
diff --git a/src/main.cpp b/src/main.cpp
index 6912b50..0601469 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -130,6 +130,7 @@ const struct option *gamescope_options = (struct option[]){
 	{ "disable-xres", no_argument, nullptr, 'x' },
 	{ "fade-out-duration", required_argument, nullptr, 0 },
 	{ "force-orientation", required_argument, nullptr, 0 },
+	{ "force-external-orientation", required_argument, nullptr, 0 },
 	{ "force-windows-fullscreen", no_argument, nullptr, 0 },
 
 	{ "disable-color-management", no_argument, nullptr, 0 },
@@ -193,6 +194,7 @@ const char usage[] =
 	"  --xwayland-count               create N xwayland servers\n"
 	"  --prefer-vk-device             prefer Vulkan device for compositing (ex: 1002:7300)\n"
 	"  --force-orientation            rotate the internal display (left, right, normal, upsidedown)\n"
+	"  --force-external-orientation   rotate the external display (left, right, normal, upsidedown)\n"
 	"  --force-windows-fullscreen     force windows inside of gamescope to be the size of the nested display (fullscreen)\n"
 	"  --cursor-scale-height          if specified, sets a base output height to linearly scale the cursor against.\n"
 	"  --hdr-enabled                  enable HDR output (needs Gamescope WSI layer enabled for support from clients)\n"
@@ -288,6 +290,8 @@ bool g_bOutputHDREnabled = false;
 bool g_bFullscreen = false;
 bool g_bForceRelativeMouse = false;
 
+bool g_bExternalForced = false;
+
 bool g_bGrabbed = false;
 
 float g_mouseSensitivity = 1.0;
@@ -361,7 +365,24 @@ static GamescopePanelOrientation force_orientation(const char *str)
 	} else if (strcmp(str, "upsidedown") == 0) {
 		return GAMESCOPE_PANEL_ORIENTATION_180;
 	} else {
-		fprintf( stderr, "gamescope: invalid value for --force-orientation\n" );
+		fprintf( stderr, "gamescope: invalid value for given for --force-orientation\n" );
+		exit(1);
+	}
+}
+
+GamescopePanelOrientation g_DesiredExternalOrientation = GAMESCOPE_PANEL_ORIENTATION_AUTO;
+static GamescopePanelOrientation force_external_orientation(const char *str)
+{
+	if (strcmp(str, "normal") == 0) {
+		return GAMESCOPE_PANEL_ORIENTATION_0;
+	} else if (strcmp(str, "right") == 0) {
+		return GAMESCOPE_PANEL_ORIENTATION_270;
+	} else if (strcmp(str, "left") == 0) {
+		return GAMESCOPE_PANEL_ORIENTATION_90;
+	} else if (strcmp(str, "upsidedown") == 0) {
+		return GAMESCOPE_PANEL_ORIENTATION_180;
+	} else {
+		fprintf( stderr, "gamescope: invalid value for --force-external-orientation\n" );
 		exit(1);
 	}
 }
@@ -751,6 +772,8 @@ int main(int argc, char **argv)
 					g_eGamescopeModeGeneration = parse_gamescope_mode_generation( optarg );
 				} else if (strcmp(opt_name, "force-orientation") == 0) {
 					g_DesiredInternalOrientation = force_orientation( optarg );
+				} else if (strcmp(opt_name, "force-external-orientation") == 0) {
+					g_DesiredExternalOrientation = force_external_orientation( optarg );
 				} else if (strcmp(opt_name, "sharpness") == 0 ||
 						   strcmp(opt_name, "fsr-sharpness") == 0) {
 					g_upscaleFilterSharpness = atoi( optarg );
diff --git a/src/main.hpp b/src/main.hpp
index 2e6fb83..ebd018a 100644
--- a/src/main.hpp
+++ b/src/main.hpp
@@ -28,6 +28,7 @@ extern bool g_bGrabbed;
 
 extern float g_mouseSensitivity;
 extern const char *g_sOutputName;
+extern bool g_bExternalForced;
 
 enum class GamescopeUpscaleFilter : uint32_t
 {
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index ceeef24..62876c2 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -2499,6 +2499,29 @@ static void apply_touchscreen_orientation(double *x, double *y )
 			break;
 	}
 
+	// Rotate screen if it's forced with --force-external-orientation
+	switch ( GetBackend()->GetConnector( gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL )->GetCurrentOrientation() )
+	{
+		default:
+		case GAMESCOPE_PANEL_ORIENTATION_AUTO:
+		case GAMESCOPE_PANEL_ORIENTATION_0:
+			tx = *x;
+			ty = *y;
+			break;
+		case GAMESCOPE_PANEL_ORIENTATION_90:
+			tx = 1.0 - *y;
+			ty = *x;
+			break;
+		case GAMESCOPE_PANEL_ORIENTATION_180:
+			tx = 1.0 - *x;
+			ty = 1.0 - *y;
+			break;
+		case GAMESCOPE_PANEL_ORIENTATION_270:
+			tx = *y;
+			ty = 1.0 - *x;
+			break;
+	}
+
 	*x = tx;
 	*y = ty;
 }
-- 
2.47.1


From 52d9d35a13ae8bad66be47da89d00353c60a1638 Mon Sep 17 00:00:00 2001
From: Bouke Sybren Haarsma <boukehaarsma23@gmail.com>
Date: Tue, 12 Mar 2024 00:07:57 +0100
Subject: [PATCH 03/19] implement force-panel-type

---
 src/backend.h          |  3 +++
 src/gamescope_shared.h |  1 +
 src/main.cpp           | 16 ++++++++++++++++
 3 files changed, 20 insertions(+)

diff --git a/src/backend.h b/src/backend.h
index dd295f4..71c41a7 100644
--- a/src/backend.h
+++ b/src/backend.h
@@ -20,6 +20,7 @@ struct wlr_buffer;
 struct wlr_dmabuf_attributes;
 
 struct FrameInfo_t;
+extern gamescope::GamescopeScreenType g_ForcedScreenType;
 
 namespace gamescope
 {
@@ -228,6 +229,8 @@ namespace gamescope
         // Dumb helper we should remove to support multi display someday.
         gamescope::GamescopeScreenType GetScreenType()
         {
+            if (g_ForcedScreenType != GAMESCOPE_SCREEN_TYPE_AUTO)
+                return g_ForcedScreenType;
             if ( GetCurrentConnector() )
                 return GetCurrentConnector()->GetScreenType();
 
diff --git a/src/gamescope_shared.h b/src/gamescope_shared.h
index 1ff54bd..feffdc1 100644
--- a/src/gamescope_shared.h
+++ b/src/gamescope_shared.h
@@ -16,6 +16,7 @@ namespace gamescope
 	{
 		GAMESCOPE_SCREEN_TYPE_INTERNAL,
 		GAMESCOPE_SCREEN_TYPE_EXTERNAL,
+		GAMESCOPE_SCREEN_TYPE_AUTO,
 
 		GAMESCOPE_SCREEN_TYPE_COUNT
 	};
diff --git a/src/main.cpp b/src/main.cpp
index 0601469..58e273f 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -131,6 +131,7 @@ const struct option *gamescope_options = (struct option[]){
 	{ "fade-out-duration", required_argument, nullptr, 0 },
 	{ "force-orientation", required_argument, nullptr, 0 },
 	{ "force-external-orientation", required_argument, nullptr, 0 },
+	{ "force-panel-type", required_argument, nullptr, 0 },
 	{ "force-windows-fullscreen", no_argument, nullptr, 0 },
 
 	{ "disable-color-management", no_argument, nullptr, 0 },
@@ -195,6 +196,7 @@ const char usage[] =
 	"  --prefer-vk-device             prefer Vulkan device for compositing (ex: 1002:7300)\n"
 	"  --force-orientation            rotate the internal display (left, right, normal, upsidedown)\n"
 	"  --force-external-orientation   rotate the external display (left, right, normal, upsidedown)\n"
+	"  --force-panel-type             force gamescope to treat the display as either internal or external\n"
 	"  --force-windows-fullscreen     force windows inside of gamescope to be the size of the nested display (fullscreen)\n"
 	"  --cursor-scale-height          if specified, sets a base output height to linearly scale the cursor against.\n"
 	"  --hdr-enabled                  enable HDR output (needs Gamescope WSI layer enabled for support from clients)\n"
@@ -386,6 +388,18 @@ static GamescopePanelOrientation force_external_orientation(const char *str)
 		exit(1);
 	}
 }
+gamescope::GamescopeScreenType g_ForcedScreenType = gamescope::GAMESCOPE_SCREEN_TYPE_AUTO;
+static gamescope::GamescopeScreenType force_panel_type(const char *str)
+{
+	if (strcmp(str, "internal") == 0) {
+		return gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL;
+	} else if (strcmp(str, "external") == 0) {
+		return gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL;
+	} else {
+		fprintf( stderr, "gamescope: invalid value for --force-panel-type\n" );
+		exit(1);
+	}
+}
 
 static enum GamescopeUpscaleScaler parse_upscaler_scaler(const char *str)
 {
@@ -774,6 +788,8 @@ int main(int argc, char **argv)
 					g_DesiredInternalOrientation = force_orientation( optarg );
 				} else if (strcmp(opt_name, "force-external-orientation") == 0) {
 					g_DesiredExternalOrientation = force_external_orientation( optarg );
+				} else if (strcmp(opt_name, "force-panel-type") == 0) {
+					g_ForcedScreenType = force_panel_type( optarg );
 				} else if (strcmp(opt_name, "sharpness") == 0 ||
 						   strcmp(opt_name, "fsr-sharpness") == 0) {
 					g_upscaleFilterSharpness = atoi( optarg );
-- 
2.47.1


From 1aaf1a1ed46195d564c80c7d56251f09fde53aef Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Fri, 17 May 2024 21:11:34 -0500
Subject: [PATCH 04/19] wlserver: Fix an issue that would cause gamescope to
 crash when the touchscreen was used

---
 src/wlserver.cpp | 23 -----------------------
 1 file changed, 23 deletions(-)

diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index 62876c2..ceeef24 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -2499,29 +2499,6 @@ static void apply_touchscreen_orientation(double *x, double *y )
 			break;
 	}
 
-	// Rotate screen if it's forced with --force-external-orientation
-	switch ( GetBackend()->GetConnector( gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL )->GetCurrentOrientation() )
-	{
-		default:
-		case GAMESCOPE_PANEL_ORIENTATION_AUTO:
-		case GAMESCOPE_PANEL_ORIENTATION_0:
-			tx = *x;
-			ty = *y;
-			break;
-		case GAMESCOPE_PANEL_ORIENTATION_90:
-			tx = 1.0 - *y;
-			ty = *x;
-			break;
-		case GAMESCOPE_PANEL_ORIENTATION_180:
-			tx = 1.0 - *x;
-			ty = 1.0 - *y;
-			break;
-		case GAMESCOPE_PANEL_ORIENTATION_270:
-			tx = *y;
-			ty = 1.0 - *x;
-			break;
-	}
-
 	*x = tx;
 	*y = ty;
 }
-- 
2.47.1


From 94e77c7f51ba1fd84d9f4fcccefefe6ad9fc8ae5 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Fri, 17 May 2024 21:56:55 -0500
Subject: [PATCH 05/19] Add --custom-refresh-rates

---
 src/Backends/DRMBackend.cpp |  6 ++++++
 src/main.cpp                | 31 ++++++++++++++++++++++++++++++-
 src/main.hpp                |  2 ++
 3 files changed, 38 insertions(+), 1 deletion(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 6bc64fa..5341bbf 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2339,6 +2339,12 @@ namespace gamescope
 				m_Mutable.HDR.bExposeHDRSupport = false;
 			}
 		}
+
+		// Apply command line overrides
+		if ( g_customRefreshRates.size() > 0 && ( GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL || g_bExternalForced ) ) {
+			m_Mutable.ValidDynamicRefreshRates.clear();
+			m_Mutable.ValidDynamicRefreshRates = std::vector(g_customRefreshRates);
+		}
 	}
 
 	/////////////////////////
diff --git a/src/main.cpp b/src/main.cpp
index 58e273f..e6782e0 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -133,7 +133,7 @@ const struct option *gamescope_options = (struct option[]){
 	{ "force-external-orientation", required_argument, nullptr, 0 },
 	{ "force-panel-type", required_argument, nullptr, 0 },
 	{ "force-windows-fullscreen", no_argument, nullptr, 0 },
-
+	{ "custom-refresh-rates", required_argument, nullptr, 0 },
 	{ "disable-color-management", no_argument, nullptr, 0 },
 	{ "sdr-gamut-wideness", required_argument, nullptr, 0 },
 	{ "hdr-enabled", no_argument, nullptr, 0 },
@@ -209,6 +209,7 @@ const char usage[] =
 	"  --hdr-itm-target-nits          set the target luminace of the inverse tone mapping process.\n"
 	"                                 Default: 1000 nits, Max: 10000 nits\n"
 	"  --framerate-limit              Set a simple framerate limit. Used as a divisor of the refresh rate, rounds down eg 60 / 59 -> 60fps, 60 / 25 -> 30fps. Default: 0, disabled.\n"
+	"  --custom-refresh-rates         Set custom refresh rates for the output. eg: 60,90,110-120\n"
 	"  --mangoapp                     Launch with the mangoapp (mangohud) performance overlay enabled. You should use this instead of using mangohud on the game or gamescope.\n"
 	"\n"
 	"Nested mode options:\n"
@@ -461,6 +462,32 @@ static enum gamescope::GamescopeBackend parse_backend_name(const char *str)
 		fprintf( stderr, "gamescope: invalid value for --backend\n" );
 		exit(1);
 	}
+
+std::vector<uint32_t> g_customRefreshRates;
+// eg: 60,60,90,110-120
+static std::vector<uint32_t> parse_custom_refresh_rates( const char *str )
+{
+	std::vector<uint32_t> rates;
+	char *token = strtok( strdup(str), ",");
+	while (token)
+	{
+		char *dash = strchr(token, '-');
+		if (dash)
+		{
+			uint32_t start = atoi(token);
+			uint32_t end = atoi(dash + 1);
+			for (uint32_t i = start; i <= end; i++)
+			{
+				rates.push_back(i);
+			}
+		}
+		else
+		{
+			rates.push_back(atoi(token));
+		}
+		token = strtok(nullptr, ",");
+	}
+	return rates;
 }
 
 struct sigaction handle_signal_action = {};
@@ -790,6 +817,8 @@ int main(int argc, char **argv)
 					g_DesiredExternalOrientation = force_external_orientation( optarg );
 				} else if (strcmp(opt_name, "force-panel-type") == 0) {
 					g_ForcedScreenType = force_panel_type( optarg );
+				} else if (strcmp(opt_name, "custom-refresh-rates") == 0) {
+					g_customRefreshRates = parse_custom_refresh_rates( optarg );
 				} else if (strcmp(opt_name, "sharpness") == 0 ||
 						   strcmp(opt_name, "fsr-sharpness") == 0) {
 					g_upscaleFilterSharpness = atoi( optarg );
diff --git a/src/main.hpp b/src/main.hpp
index ebd018a..4e09e3b 100644
--- a/src/main.hpp
+++ b/src/main.hpp
@@ -3,6 +3,7 @@
 #include <getopt.h>
 
 #include <atomic>
+#include <vector>
 
 extern const char *gamescope_optstring;
 extern const struct option *gamescope_options;
@@ -29,6 +30,7 @@ extern bool g_bGrabbed;
 extern float g_mouseSensitivity;
 extern const char *g_sOutputName;
 extern bool g_bExternalForced;
+extern std::vector<uint32_t> g_customRefreshRates;
 
 enum class GamescopeUpscaleFilter : uint32_t
 {
-- 
2.47.1


From bf90ce80d7130c7dd23da5eb6086ca3452a33b6e Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Sat, 18 May 2024 08:44:38 -0500
Subject: [PATCH 06/19] Add rotation gamescope_control command

---
 protocol/gamescope-control.xml | 18 ++++++++++++
 src/Backends/DRMBackend.cpp    | 24 ++++++++++++++--
 src/gamescope_shared.h         | 10 +++++++
 src/main.cpp                   |  1 +
 src/wlserver.cpp               | 50 ++++++++++++++++++++++++++++++++++
 5 files changed, 101 insertions(+), 2 deletions(-)

diff --git a/protocol/gamescope-control.xml b/protocol/gamescope-control.xml
index 012c48c..eab8a84 100644
--- a/protocol/gamescope-control.xml
+++ b/protocol/gamescope-control.xml
@@ -99,5 +99,23 @@
       <arg name="path" type="string" summary="Path to written screenshot"></arg>
     </event>
 
+
+    <enum name="display_rotation_flag" bitfield="true" since="2">
+      <entry name="normal" value="1"/>
+      <entry name="left" value="2"/>
+      <entry name="right" value="3"/>
+      <entry name="upsidedown" value="4"/>
+    </enum>
+
+    <enum name="display_target_type" since="2">
+      <entry name="internal" value="1"/>
+      <entry name="external" value="2"/>
+    </enum>
+
+    <request name="rotate_display" since="2">
+      <arg name="orientation" type="uint" enum="display_rotation_flag" summary="Set the orientation of the display output."/>
+      <arg name="target_type" type="uint" enum="display_target_type" summary="Internal (1) or External (2) target type."/>
+    </request>
+
   </interface>
 </protocol>
diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 5341bbf..06200ae 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2023,7 +2023,9 @@ namespace gamescope
 
 	void CDRMConnector::UpdateEffectiveOrientation( const drmModeModeInfo *pMode )
 	{
-		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO )
+		if ( this->GetScreenType() == ( GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO )
+										|| ( GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO
+											&& g_bExternalForced ) )
 		{
 			m_ChosenOrientation = g_DesiredInternalOrientation;
 		}
@@ -2962,8 +2964,26 @@ bool drm_update_color_mgmt(struct drm_t *drm)
 	return true;
 }
 
-int g_nDynamicRefreshHz = 0;
+void drm_set_orientation( struct drm_t *drm, bool isRotated)
+{
+	int width = g_nOutputWidth;
+	int height = g_nOutputHeight;
+	g_bRotated = isRotated;
+	if ( g_bRotated ) {
+		int tmp = width;
+		width = height;
+		height = tmp;
+	}
 
+	if (!drm->pConnector || !drm->pConnector->GetModeConnector())
+		return;
+
+	drmModeConnector *connector = drm->pConnector->GetModeConnector();
+	const drmModeModeInfo *mode = find_mode(connector, width, height, 0);
+	update_drm_effective_orientations(drm, mode);
+}
+
+int g_nDynamicRefreshHz = 0;
 static void drm_unset_mode( struct drm_t *drm )
 {
 	drm->pending.mode_id = 0;
diff --git a/src/gamescope_shared.h b/src/gamescope_shared.h
index feffdc1..6e6b7db 100644
--- a/src/gamescope_shared.h
+++ b/src/gamescope_shared.h
@@ -56,6 +56,16 @@ enum GamescopePanelOrientation
 	GAMESCOPE_PANEL_ORIENTATION_AUTO,
 };
 
+enum GamescopePanelExternalOrientation
+{
+	GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_0,   // normal
+	GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_270, // right
+	GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_90,  // left
+	GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_180, // upside down
+
+	GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_AUTO,
+};
+
 // Disable partial composition for now until we get
 // composite priorities working in libliftoff + also
 // use the proper libliftoff composite plane system.
diff --git a/src/main.cpp b/src/main.cpp
index e6782e0..14eb513 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -395,6 +395,7 @@ static gamescope::GamescopeScreenType force_panel_type(const char *str)
 	if (strcmp(str, "internal") == 0) {
 		return gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL;
 	} else if (strcmp(str, "external") == 0) {
+		g_bExternalForced = true;
 		return gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL;
 	} else {
 		fprintf( stderr, "gamescope: invalid value for --force-panel-type\n" );
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index ceeef24..e386765 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -1043,6 +1043,55 @@ static void gamescope_control_take_screenshot( struct wl_client *client, struct
 	} );
 }
 
+static void gamescope_control_rotate_display( struct wl_client *client, struct wl_resource *resource, uint32_t orientation, uint32_t target_type )
+{
+	bool isRotated = false;
+	if (target_type == GAMESCOPE_CONTROL_DISPLAY_TARGET_TYPE_INTERNAL )
+	{
+		switch (orientation) {
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_NORMAL:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_0;
+			break;
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_LEFT:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_90;
+			isRotated = true;
+			break;
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_RIGHT:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_270;
+			isRotated = true;
+			break;
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_UPSIDEDOWN:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_180;
+			break;
+		default:
+			wl_log.errorf("Invalid target orientation selected");
+		}
+	}
+	else if (target_type == GAMESCOPE_CONTROL_DISPLAY_TARGET_TYPE_EXTERNAL )
+	{
+		switch (orientation) {
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_NORMAL:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_0;
+			break;
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_LEFT:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_90;
+			isRotated = true;
+			break;
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_RIGHT:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_270;
+			isRotated = true;
+			break;
+		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_UPSIDEDOWN:
+			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_180;
+			break;
+		default:
+			wl_log.errorf("Invalid target orientation selected");
+		}
+	}
+	//drm_set_orientation(&g_DRM, isRotated);
+	//g_DRM.out_of_date = 2;
+}
+
 static void gamescope_control_handle_destroy( struct wl_client *client, struct wl_resource *resource )
 {
 	wl_resource_destroy( resource );
@@ -1052,6 +1101,7 @@ static const struct gamescope_control_interface gamescope_control_impl = {
 	.destroy = gamescope_control_handle_destroy,
 	.set_app_target_refresh_cycle = gamescope_control_set_app_target_refresh_cycle,
 	.take_screenshot = gamescope_control_take_screenshot,
+	.rotate_display = gamescope_control_rotate_display,
 };
 
 static uint32_t get_conn_display_info_flags()
-- 
2.47.1


From ae730c5a1607c35c7283722f018811387c35b130 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Sat, 18 May 2024 11:54:50 -0500
Subject: [PATCH 07/19] Fix an issue that caused force-panel to not work

---
 protocol/gamescope-control.xml |   1 -
 src/Backends/DRMBackend.cpp    |   3 +
 src/wlserver.cpp               | 145 ++++++++++++++++++++-------------
 3 files changed, 90 insertions(+), 59 deletions(-)

diff --git a/protocol/gamescope-control.xml b/protocol/gamescope-control.xml
index eab8a84..7f5578b 100644
--- a/protocol/gamescope-control.xml
+++ b/protocol/gamescope-control.xml
@@ -99,7 +99,6 @@
       <arg name="path" type="string" summary="Path to written screenshot"></arg>
     </event>
 
-
     <enum name="display_rotation_flag" bitfield="true" since="2">
       <entry name="normal" value="1"/>
       <entry name="left" value="2"/>
diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 06200ae..7c88818 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -309,6 +309,9 @@ namespace gamescope
 
 		GamescopeScreenType GetScreenType() const override
 		{
+			if ( g_ForcedScreenType != GAMESCOPE_SCREEN_TYPE_AUTO )
+				return g_ForcedScreenType;
+
 			if ( m_pConnector->connector_type == DRM_MODE_CONNECTOR_eDP ||
 				 m_pConnector->connector_type == DRM_MODE_CONNECTOR_LVDS ||
 				 m_pConnector->connector_type == DRM_MODE_CONNECTOR_DSI )
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index e386765..a3af652 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -83,6 +83,8 @@ extern gamescope::ConVar<bool> cv_drm_debug_disable_explicit_sync;
 
 //#define GAMESCOPE_SWAPCHAIN_DEBUG
 gamescope::ConVar<bool> cv_touch_gestures( "enable_touch_gestures", false, "Enable/Disable the usage of touch gestures" );
+extern GamescopePanelOrientation g_DesiredInternalOrientation;
+extern GamescopePanelOrientation g_DesiredExternalOrientation;
 
 struct wlserver_t wlserver = {
 	.touch_down_ids = {}
@@ -1049,43 +1051,43 @@ static void gamescope_control_rotate_display( struct wl_client *client, struct w
 	if (target_type == GAMESCOPE_CONTROL_DISPLAY_TARGET_TYPE_INTERNAL )
 	{
 		switch (orientation) {
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_NORMAL:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_0;
-			break;
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_LEFT:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_90;
-			isRotated = true;
-			break;
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_RIGHT:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_270;
-			isRotated = true;
-			break;
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_UPSIDEDOWN:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_180;
-			break;
-		default:
-			wl_log.errorf("Invalid target orientation selected");
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_NORMAL:
+				g_DesiredInternalOrientation = GAMESCOPE_PANEL_ORIENTATION_0;
+				break;
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_LEFT:
+				g_DesiredInternalOrientation = GAMESCOPE_PANEL_ORIENTATION_90;
+				isRotated = true;
+				break;
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_RIGHT:
+				g_DesiredInternalOrientation = GAMESCOPE_PANEL_ORIENTATION_270;
+				isRotated = true;
+				break;
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_UPSIDEDOWN:
+				g_DesiredInternalOrientation = GAMESCOPE_PANEL_ORIENTATION_180;
+				break;
+			default:
+				wl_log.errorf("Invalid target orientation selected");
 		}
 	}
 	else if (target_type == GAMESCOPE_CONTROL_DISPLAY_TARGET_TYPE_EXTERNAL )
 	{
 		switch (orientation) {
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_NORMAL:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_0;
-			break;
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_LEFT:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_90;
-			isRotated = true;
-			break;
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_RIGHT:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_270;
-			isRotated = true;
-			break;
-		case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_UPSIDEDOWN:
-			//m_ChosenOrientation = GAMESCOPE_PANEL_EXTERNAL_ORIENTATION_180;
-			break;
-		default:
-			wl_log.errorf("Invalid target orientation selected");
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_NORMAL:
+				g_DesiredExternalOrientation = GAMESCOPE_PANEL_ORIENTATION_0;
+				break;
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_LEFT:
+				g_DesiredExternalOrientation = GAMESCOPE_PANEL_ORIENTATION_90;
+				isRotated = true;
+				break;
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_RIGHT:
+				g_DesiredExternalOrientation = GAMESCOPE_PANEL_ORIENTATION_270;
+				isRotated = true;
+				break;
+			case GAMESCOPE_CONTROL_DISPLAY_ROTATION_FLAG_UPSIDEDOWN:
+				g_DesiredExternalOrientation = GAMESCOPE_PANEL_ORIENTATION_180;
+				break;
+			default:
+				wl_log.errorf("Invalid target orientation selected");
 		}
 	}
 	//drm_set_orientation(&g_DRM, isRotated);
@@ -2523,34 +2525,61 @@ const std::shared_ptr<wlserver_vk_swapchain_feedback>& wlserver_surface_swapchai
 /* Handle the orientation of the touch inputs */
 static void apply_touchscreen_orientation(double *x, double *y )
 {
-	double tx = 0;
-	double ty = 0;
+    double tx = 0;
+    double ty = 0;
 
-	// Use internal screen always for orientation purposes.
-	switch ( GetBackend()->GetConnector( gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL )->GetCurrentOrientation() )
-	{
-		default:
-		case GAMESCOPE_PANEL_ORIENTATION_AUTO:
-		case GAMESCOPE_PANEL_ORIENTATION_0:
-			tx = *x;
-			ty = *y;
-			break;
-		case GAMESCOPE_PANEL_ORIENTATION_90:
-			tx = 1.0 - *y;
-			ty = *x;
-			break;
-		case GAMESCOPE_PANEL_ORIENTATION_180:
-			tx = 1.0 - *x;
-			ty = 1.0 - *y;
-			break;
-		case GAMESCOPE_PANEL_ORIENTATION_270:
-			tx = *y;
-			ty = 1.0 - *x;
-			break;
-	}
+    // Use internal screen always for orientation purposes.
+    if ( g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL || g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL )
+    {
+        switch ( g_DesiredInternalOrientation )
+        {
+			default:
+			case GAMESCOPE_PANEL_ORIENTATION_AUTO:
+			case GAMESCOPE_PANEL_ORIENTATION_0:
+				tx = *x;
+				ty = *y;
+				break;
+			case GAMESCOPE_PANEL_ORIENTATION_90:
+				tx = 1.0 - *y;
+				ty = *x;
+				break;
+			case GAMESCOPE_PANEL_ORIENTATION_180:
+				tx = 1.0 - *x;
+				ty = 1.0 - *y;
+				break;
+			case GAMESCOPE_PANEL_ORIENTATION_270:
+				tx = *y;
+				ty = 1.0 - *x;
+				break;
+        }
+    }
+    else if (g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_AUTO)
+    {
+        switch (GetBackend()->GetConnector(gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL)->GetCurrentOrientation())
+        {
+			default:
+			case GAMESCOPE_PANEL_ORIENTATION_AUTO:
+			case GAMESCOPE_PANEL_ORIENTATION_0:
+				tx = *x;
+				ty = *y;
+				break;
+			case GAMESCOPE_PANEL_ORIENTATION_90:
+				tx = 1.0 - *y;
+				ty = *x;
+				break;
+			case GAMESCOPE_PANEL_ORIENTATION_180:
+				tx = 1.0 - *x;
+				ty = 1.0 - *y;
+				break;
+			case GAMESCOPE_PANEL_ORIENTATION_270:
+				tx = *y;
+				ty = 1.0 - *x;
+				break;
+        }
+    }
 
-	*x = tx;
-	*y = ty;
+    *x = tx;
+    *y = ty;
 }
 
 void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool bAlwaysWarpCursor )
-- 
2.47.1


From 8963506cccfa1f3ed21ac53def17cf7402be4d45 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Sat, 18 May 2024 13:50:57 -0500
Subject: [PATCH 08/19] Fix an arithmetic error

---
 src/Backends/DRMBackend.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 7c88818..477d141 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2026,9 +2026,9 @@ namespace gamescope
 
 	void CDRMConnector::UpdateEffectiveOrientation( const drmModeModeInfo *pMode )
 	{
-		if ( this->GetScreenType() == ( GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO )
-										|| ( GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO
-											&& g_bExternalForced ) )
+		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO
+										|| GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO
+											&& g_bExternalForced )
 		{
 			m_ChosenOrientation = g_DesiredInternalOrientation;
 		}
-- 
2.47.1


From c32a4db47878b61298384771d9cbace8e1562c36 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Sat, 18 May 2024 19:04:48 -0500
Subject: [PATCH 09/19] Rework the touch gestures to be more smooth

---
 src/wlserver.cpp | 89 +++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 69 insertions(+), 20 deletions(-)

diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index a3af652..a240871 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -81,6 +81,8 @@ using namespace std::literals;
 
 extern gamescope::ConVar<bool> cv_drm_debug_disable_explicit_sync;
 
+bool pending_gesture = false;
+bool pending_osk = false;
 //#define GAMESCOPE_SWAPCHAIN_DEBUG
 gamescope::ConVar<bool> cv_touch_gestures( "enable_touch_gestures", false, "Enable/Disable the usage of touch gestures" );
 extern GamescopePanelOrientation g_DesiredInternalOrientation;
@@ -363,6 +365,39 @@ void wlserver_open_steam_menu( bool qam )
 	XTestFakeKeyEvent(server->get_xdisplay(), XKeysymToKeycode( server->get_xdisplay(), XK_Control_L ), False, CurrentTime);
 }
 
+void wlserver_open_steam_osk(bool osk)
+{
+	gamescope_xwayland_server_t *server = wlserver_get_xwayland_server( 0 );
+	if (!server)
+		return;
+
+	uint32_t osk_open = osk;
+
+	if (osk_open)
+	{
+		const char *command = "xdg-open steam://open/keyboard?";
+		int result = system(command);
+		if (result == 0) {
+			printf("Command executed successfully.\n");
+		} else {
+			printf("Error executing command.\n");
+		}
+		pending_osk = false;
+	}
+	else
+	{
+		const char *command = "xdg-open steam://close/keyboard?";
+		int result = system(command);
+		if (result == 0) {
+			printf("Command executed successfully.\n");
+		} else {
+			printf("Error executing command.\n");
+		}
+		pending_osk = false;
+	}
+
+}
+
 static void wlserver_handle_pointer_button(struct wl_listener *listener, void *data)
 {
 	struct wlserver_pointer *pointer = wl_container_of( listener, pointer, button );
@@ -2618,32 +2653,46 @@ void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool
 			if ( bAlwaysWarpCursor )
 				wlserver_mousewarp( tx, ty, time, false );
 
-			if (cv_touch_gestures) {
-				bool start_gesture = false;
-
-				// Round the x-coordinate to the nearest whole number
+			if ( cv_touch_gestures )
+			{
 				uint32_t roundedCursorX = static_cast<int>(std::round(tx));
-				// Grab 2% of the display to be used for the edge range
-				uint32_t edge_range = static_cast<uint32_t>(g_nOutputWidth * 0.02);
-
-				// Determine if the gesture should start
-				if (roundedCursorX <= edge_range || roundedCursorX >= g_nOutputWidth - edge_range) {
-					start_gesture = true;
-				}
-
-				// Handle Home gesture
-				if (start_gesture && roundedCursorX >= edge_range) {
+				uint32_t roundedCursorY = static_cast<int>(std::round(ty));
+				uint32_t edge_range_x = static_cast<uint32_t>(g_nOutputWidth * 0.02);
+				uint32_t edge_range_y = static_cast<uint32_t>(g_nOutputWidth * 0.02);
+				uint32_t gesture_limits_x = edge_range_x * 2;
+				uint32_t gesture_limits_y = edge_range_y * 2;
+
+				// Left to Right and Right to Left
+				if (!pending_gesture && roundedCursorX >= 1 && roundedCursorX < edge_range_x ||
+						!pending_gesture && roundedCursorX >= g_nOutputWidth - edge_range_x )
+					pending_gesture = true;
+
+				//left
+				if (pending_gesture && roundedCursorX >= edge_range_x && roundedCursorX < gesture_limits_x) {
 					wlserver_open_steam_menu(0);
-					start_gesture = false;
+					pending_gesture = false;
 				}
-
-				// Handle QAM gesture
-				if (start_gesture && roundedCursorX >= g_nOutputWidth - edge_range && roundedCursorX <= g_nOutputWidth) {
+				//right
+				if (pending_gesture && roundedCursorX <= g_nOutputWidth - edge_range_x && roundedCursorX > g_nOutputWidth - gesture_limits_x) {
 					wlserver_open_steam_menu(1);
-					start_gesture = false;
+					pending_gesture = false;
+				}
+				// Top to Bottom and Bottom to Top
+				if (!pending_gesture && roundedCursorY >= 1 && roundedCursorY < edge_range_y ||
+						!pending_gesture && roundedCursorY >= g_nOutputHeight - edge_range_y )
+					pending_gesture = true;
+				// Top
+				if (pending_gesture && roundedCursorY >= edge_range_y && roundedCursorY < gesture_limits_y) {
+					pending_gesture = false;
+					// Top to Bottom function to add
+				}
+				// Bottom
+				if (pending_gesture && !pending_osk && roundedCursorY <= g_nOutputWidth - edge_range_y && roundedCursorY > g_nOutputHeight - gesture_limits_y) {
+					pending_gesture = false;
+					pending_osk = true;
+					//wlserver_open_steam_osk(1);
 				}
 			}
-
 		}
 		else if ( eMode == gamescope::TouchClickModes::Disabled )
 		{
-- 
2.47.1


From 068d28042c1f768f53cd0dc64d091b8342024d1f Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Sun, 19 May 2024 11:48:52 -0500
Subject: [PATCH 10/19] Handle gesture cases better to prevent unexpected
 behavior

---
 src/wlserver.cpp | 63 +++++++++++++++++++++++++++++++++---------------
 1 file changed, 43 insertions(+), 20 deletions(-)

diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index a240871..3837c84 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -81,7 +81,8 @@ using namespace std::literals;
 
 extern gamescope::ConVar<bool> cv_drm_debug_disable_explicit_sync;
 
-bool pending_gesture = false;
+bool pending_gesture_x = false;
+bool pending_gesture_y = false;
 bool pending_osk = false;
 //#define GAMESCOPE_SWAPCHAIN_DEBUG
 gamescope::ConVar<bool> cv_touch_gestures( "enable_touch_gestures", false, "Enable/Disable the usage of touch gestures" );
@@ -2617,6 +2618,16 @@ static void apply_touchscreen_orientation(double *x, double *y )
     *y = ty;
 }
 
+void wlserver_gesture_flush()
+{
+	pending_gesture_x = false;
+	pending_gesture_y = false;
+}
+
+// Variables to track the direction of the touch motion
+uint32_t previous_tx = 0;
+uint32_t previous_ty = 0;
+
 void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool bAlwaysWarpCursor )
 {
 	assert( wlserver_is_lock_held() );
@@ -2655,43 +2666,55 @@ void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool
 
 			if ( cv_touch_gestures )
 			{
-				uint32_t roundedCursorX = static_cast<int>(std::round(tx));
-				uint32_t roundedCursorY = static_cast<int>(std::round(ty));
-				uint32_t edge_range_x = static_cast<uint32_t>(g_nOutputWidth * 0.02);
-				uint32_t edge_range_y = static_cast<uint32_t>(g_nOutputWidth * 0.02);
+				uint32_t rounded_tx = static_cast<int>(std::round(tx));
+				uint32_t rounded_ty = static_cast<int>(std::round(ty));
+				uint32_t edge_range_x = static_cast<uint32_t>(g_nOutputWidth * 0.05);
+				uint32_t edge_range_y = static_cast<uint32_t>(g_nOutputWidth * 0.05);
 				uint32_t gesture_limits_x = edge_range_x * 2;
 				uint32_t gesture_limits_y = edge_range_y * 2;
+				uint32_t threshold_distance_x = gesture_limits_x;
+				uint32_t threshold_distance_y = gesture_limits_y;
 
 				// Left to Right and Right to Left
-				if (!pending_gesture && roundedCursorX >= 1 && roundedCursorX < edge_range_x ||
-						!pending_gesture && roundedCursorX >= g_nOutputWidth - edge_range_x )
-					pending_gesture = true;
+				if (!pending_gesture_x && ((rounded_tx >= 1 && rounded_tx < edge_range_x) || (rounded_tx >= g_nOutputWidth - edge_range_x))) {
+					// Check if the distance moved is greater than the threshold
+					if (rounded_tx - previous_tx > threshold_distance_x) {
+						pending_gesture_x = true;
+					}
+				}
+
+				// Top to Bottom and Bottom to Top
+				if (!pending_gesture_y && ((rounded_ty >= 1 && rounded_ty < edge_range_y) || (rounded_ty >= g_nOutputHeight - edge_range_y))) {
+					// Check if the distance moved is greater than the threshold
+					if (rounded_ty - previous_ty > threshold_distance_y) {
+						pending_gesture_y = true;
+					}
+				}
 
 				//left
-				if (pending_gesture && roundedCursorX >= edge_range_x && roundedCursorX < gesture_limits_x) {
+				if (pending_gesture_x && previous_tx < rounded_tx && rounded_tx >= edge_range_x && rounded_tx < gesture_limits_x) {
 					wlserver_open_steam_menu(0);
-					pending_gesture = false;
+					wlserver_gesture_flush();
 				}
 				//right
-				if (pending_gesture && roundedCursorX <= g_nOutputWidth - edge_range_x && roundedCursorX > g_nOutputWidth - gesture_limits_x) {
+				if (pending_gesture_x && previous_tx > rounded_tx && rounded_tx <= g_nOutputWidth - edge_range_x && rounded_tx > g_nOutputWidth - gesture_limits_x) {
 					wlserver_open_steam_menu(1);
-					pending_gesture = false;
+					wlserver_gesture_flush();
 				}
-				// Top to Bottom and Bottom to Top
-				if (!pending_gesture && roundedCursorY >= 1 && roundedCursorY < edge_range_y ||
-						!pending_gesture && roundedCursorY >= g_nOutputHeight - edge_range_y )
-					pending_gesture = true;
+
 				// Top
-				if (pending_gesture && roundedCursorY >= edge_range_y && roundedCursorY < gesture_limits_y) {
-					pending_gesture = false;
+				if (pending_gesture_y && previous_ty < rounded_ty && rounded_ty >= edge_range_y && rounded_ty < gesture_limits_y) {
+					wlserver_gesture_flush();
 					// Top to Bottom function to add
 				}
 				// Bottom
-				if (pending_gesture && !pending_osk && roundedCursorY <= g_nOutputWidth - edge_range_y && roundedCursorY > g_nOutputHeight - gesture_limits_y) {
-					pending_gesture = false;
+				if (pending_gesture_y && previous_ty > rounded_ty && !pending_osk && rounded_ty <= g_nOutputWidth - edge_range_y && rounded_ty > g_nOutputHeight - gesture_limits_y) {
+					wlserver_gesture_flush();
 					pending_osk = true;
 					//wlserver_open_steam_osk(1);
 				}
+				previous_tx = rounded_tx;
+				previous_ty = rounded_ty;
 			}
 		}
 		else if ( eMode == gamescope::TouchClickModes::Disabled )
-- 
2.47.1


From 880d048fd51ddbe8d4d6bae750640385792adcba Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Sun, 19 May 2024 18:14:23 -0500
Subject: [PATCH 11/19] Add references to drm_set_orientation() and g_drm in
 wlserver for rotation gamescope-control

---
 src/wlserver.cpp | 5 +++--
 src/wlserver.hpp | 3 ++-
 2 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index 3837c84..13ea8b5 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -1126,8 +1126,9 @@ static void gamescope_control_rotate_display( struct wl_client *client, struct w
 				wl_log.errorf("Invalid target orientation selected");
 		}
 	}
-	//drm_set_orientation(&g_DRM, isRotated);
-	//g_DRM.out_of_date = 2;
+	drm_set_orientation(&g_DRM, isRotated);
+	GetBackend()->DirtyState( true, true );
+
 }
 
 static void gamescope_control_handle_destroy( struct wl_client *client, struct wl_resource *resource )
diff --git a/src/wlserver.hpp b/src/wlserver.hpp
index 3304c18..0754ee5 100644
--- a/src/wlserver.hpp
+++ b/src/wlserver.hpp
@@ -275,7 +275,8 @@ extern std::atomic<bool> g_bPendingTouchMovement;
 extern gamescope::ConVar<bool> cv_touch_gestures;
 
 void wlserver_open_steam_menu( bool qam );
-
+extern void drm_set_orientation( struct drm_t *drm, bool isRotated);
+extern drm_t g_DRM;
 uint32_t wlserver_make_new_xwayland_server();
 void wlserver_destroy_xwayland_server(gamescope_xwayland_server_t *server);
 
-- 
2.47.1


From bbf77117ca4d866cf745334630c6d6d3c44d892a Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Mon, 20 May 2024 07:02:52 -0500
Subject: [PATCH 12/19] Fix an issue where forced panel type orientations
 weren't being applied

---
 src/Backends/DRMBackend.cpp | 15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 477d141..5967794 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2026,20 +2026,19 @@ namespace gamescope
 
 	void CDRMConnector::UpdateEffectiveOrientation( const drmModeModeInfo *pMode )
 	{
-		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO
-										|| GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO
-											&& g_bExternalForced )
-		{
+		if ((this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO) ||
+			(this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO && g_bExternalForced)) {
+			drm_log.infof("We are rotating the orientation of the internal or faked external display")
 			m_ChosenOrientation = g_DesiredInternalOrientation;
-		}
-		else if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO )
-		{
+		} else if (this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO) {
+			drm_log.infof("We are rotating the orientation of an external display");
 			m_ChosenOrientation = g_DesiredExternalOrientation;
 		}
 		else
 		{
 			if ( this->GetProperties().panel_orientation )
 			{
+				drm_log.infof("We are using a kernel orientation quirk to rotate the display");
 				switch ( this->GetProperties().panel_orientation->GetCurrentValue() )
 				{
 					case DRM_MODE_PANEL_ORIENTATION_NORMAL:
@@ -2061,6 +2060,7 @@ namespace gamescope
 
 			if ( this->GetScreenType() == gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL && pMode )
 			{
+				drm_log.infof("We are using legacy code to rotate the display");
 				// Auto-detect portait mode for internal displays
 				m_ChosenOrientation = pMode->hdisplay < pMode->vdisplay
 					? GAMESCOPE_PANEL_ORIENTATION_270
@@ -2068,6 +2068,7 @@ namespace gamescope
 			}
 			else
 			{
+				drm_log.infof("No orientation quirks have been applied");
 				m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_0;
 			}
 		}
-- 
2.47.1


From 9ebad0d78422611b5fdb7270f9128ea620668da2 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Mon, 20 May 2024 07:25:29 -0500
Subject: [PATCH 13/19] add missing curly bracket...

---
 src/Backends/DRMBackend.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 5967794..3bf69dc 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2028,7 +2028,7 @@ namespace gamescope
 	{
 		if ((this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO) ||
 			(this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO && g_bExternalForced)) {
-			drm_log.infof("We are rotating the orientation of the internal or faked external display")
+			drm_log.infof("We are rotating the orientation of the internal or faked external display");
 			m_ChosenOrientation = g_DesiredInternalOrientation;
 		} else if (this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO) {
 			drm_log.infof("We are rotating the orientation of an external display");
-- 
2.47.1


From 73f8184fc7a2ed01683d624c0202cdd1ede89a8f Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Mon, 20 May 2024 10:17:55 -0500
Subject: [PATCH 14/19] Fix case where real externals were rotated with faked
 external panels

---
 src/Backends/DRMBackend.cpp | 21 +++++++----
 src/wlserver.cpp            | 72 +++++++++++++++++++++++++------------
 2 files changed, 64 insertions(+), 29 deletions(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 3bf69dc..c6bbfee 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -309,13 +309,20 @@ namespace gamescope
 
 		GamescopeScreenType GetScreenType() const override
 		{
-			if ( g_ForcedScreenType != GAMESCOPE_SCREEN_TYPE_AUTO )
-				return g_ForcedScreenType;
-
 			if ( m_pConnector->connector_type == DRM_MODE_CONNECTOR_eDP ||
 				 m_pConnector->connector_type == DRM_MODE_CONNECTOR_LVDS ||
 				 m_pConnector->connector_type == DRM_MODE_CONNECTOR_DSI )
-				return GAMESCOPE_SCREEN_TYPE_INTERNAL;
+			{
+				if ( g_bExternalForced )
+				{
+					return g_ForcedScreenType;
+				}
+				else
+				{
+					return GAMESCOPE_SCREEN_TYPE_INTERNAL;
+				}
+			}
+
 
 			return GAMESCOPE_SCREEN_TYPE_EXTERNAL;
 		}
@@ -2026,11 +2033,11 @@ namespace gamescope
 
 	void CDRMConnector::UpdateEffectiveOrientation( const drmModeModeInfo *pMode )
 	{
-		if ((this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO) ||
-			(this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO && g_bExternalForced)) {
+		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO ) {
 			drm_log.infof("We are rotating the orientation of the internal or faked external display");
 			m_ChosenOrientation = g_DesiredInternalOrientation;
-		} else if (this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO) {
+		}
+		else if (this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredExternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO) {
 			drm_log.infof("We are rotating the orientation of an external display");
 			m_ChosenOrientation = g_DesiredExternalOrientation;
 		}
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index 13ea8b5..8b9201c 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -2566,29 +2566,57 @@ static void apply_touchscreen_orientation(double *x, double *y )
     double ty = 0;
 
     // Use internal screen always for orientation purposes.
-    if ( g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL || g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL )
+    if ( g_ForcedScreenType != gamescope::GAMESCOPE_SCREEN_TYPE_AUTO )
     {
-        switch ( g_DesiredInternalOrientation )
-        {
-			default:
-			case GAMESCOPE_PANEL_ORIENTATION_AUTO:
-			case GAMESCOPE_PANEL_ORIENTATION_0:
-				tx = *x;
-				ty = *y;
-				break;
-			case GAMESCOPE_PANEL_ORIENTATION_90:
-				tx = 1.0 - *y;
-				ty = *x;
-				break;
-			case GAMESCOPE_PANEL_ORIENTATION_180:
-				tx = 1.0 - *x;
-				ty = 1.0 - *y;
-				break;
-			case GAMESCOPE_PANEL_ORIENTATION_270:
-				tx = *y;
-				ty = 1.0 - *x;
-				break;
-        }
+		if ( g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL )
+		{
+			switch (GetBackend()->GetConnector(gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL)->GetCurrentOrientation())
+			{
+				default:
+				case GAMESCOPE_PANEL_ORIENTATION_AUTO:
+				case GAMESCOPE_PANEL_ORIENTATION_0:
+					tx = *x;
+					ty = *y;
+					break;
+				case GAMESCOPE_PANEL_ORIENTATION_90:
+					tx = 1.0 - *y;
+					ty = *x;
+					break;
+				case GAMESCOPE_PANEL_ORIENTATION_180:
+					tx = 1.0 - *x;
+					ty = 1.0 - *y;
+					break;
+				case GAMESCOPE_PANEL_ORIENTATION_270:
+					tx = *y;
+					ty = 1.0 - *x;
+					break;
+			}
+		}
+		else
+		{
+			switch (GetBackend()->GetConnector(gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL)->GetCurrentOrientation())
+			{
+				default:
+				case GAMESCOPE_PANEL_ORIENTATION_AUTO:
+				case GAMESCOPE_PANEL_ORIENTATION_0:
+					tx = *x;
+					ty = *y;
+					break;
+				case GAMESCOPE_PANEL_ORIENTATION_90:
+					tx = 1.0 - *y;
+					ty = *x;
+					break;
+				case GAMESCOPE_PANEL_ORIENTATION_180:
+					tx = 1.0 - *x;
+					ty = 1.0 - *y;
+					break;
+				case GAMESCOPE_PANEL_ORIENTATION_270:
+					tx = *y;
+					ty = 1.0 - *x;
+					break;
+			}
+		}
+
     }
     else if (g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_AUTO)
     {
-- 
2.47.1


From e0edcdb13d81fb822b748b4d6ac03183c828059d Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Mon, 20 May 2024 16:30:47 -0500
Subject: [PATCH 15/19] Add verbose panel logs and attempt to address all
 orientation issues

---
 src/Backends/DRMBackend.cpp | 18 ++++++++++++++--
 src/wlserver.cpp            | 41 ++++++++++++++++++++-----------------
 src/wlserver.hpp            |  1 +
 3 files changed, 39 insertions(+), 21 deletions(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index c6bbfee..89b2802 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -58,6 +58,7 @@ static constexpr bool k_bUseCursorPlane = false;
 
 extern int g_nPreferredOutputWidth;
 extern int g_nPreferredOutputHeight;
+bool panelTypeChanged = false;
 
 gamescope::ConVar<bool> cv_drm_single_plane_optimizations( "drm_single_plane_optimizations", true, "Whether or not to enable optimizations for single plane usage." );
 
@@ -315,6 +316,7 @@ namespace gamescope
 			{
 				if ( g_bExternalForced )
 				{
+					panelTypeChanged = true;
 					return g_ForcedScreenType;
 				}
 				else
@@ -323,7 +325,7 @@ namespace gamescope
 				}
 			}
 
-
+			panelTypeChanged = false;
 			return GAMESCOPE_SCREEN_TYPE_EXTERNAL;
 		}
 
@@ -2033,7 +2035,19 @@ namespace gamescope
 
 	void CDRMConnector::UpdateEffectiveOrientation( const drmModeModeInfo *pMode )
 	{
-		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO ) {
+
+		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && panelTypeChanged )
+			drm_log.infof("Display is internal faked as external");
+		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && !panelTypeChanged )
+			drm_log.infof("Display is real internal");
+		if (panelTypeChanged){
+			drm_log.infof("Panel type was changed");
+		}
+
+		if (( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO ) ||
+			( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO
+			  && panelTypeChanged)) {
+
 			drm_log.infof("We are rotating the orientation of the internal or faked external display");
 			m_ChosenOrientation = g_DesiredInternalOrientation;
 		}
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index 8b9201c..7adf7db 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -2570,26 +2570,29 @@ static void apply_touchscreen_orientation(double *x, double *y )
     {
 		if ( g_ForcedScreenType == gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL )
 		{
-			switch (GetBackend()->GetConnector(gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL)->GetCurrentOrientation())
+			if(panelTypeChanged)
 			{
-				default:
-				case GAMESCOPE_PANEL_ORIENTATION_AUTO:
-				case GAMESCOPE_PANEL_ORIENTATION_0:
-					tx = *x;
-					ty = *y;
-					break;
-				case GAMESCOPE_PANEL_ORIENTATION_90:
-					tx = 1.0 - *y;
-					ty = *x;
-					break;
-				case GAMESCOPE_PANEL_ORIENTATION_180:
-					tx = 1.0 - *x;
-					ty = 1.0 - *y;
-					break;
-				case GAMESCOPE_PANEL_ORIENTATION_270:
-					tx = *y;
-					ty = 1.0 - *x;
-					break;
+				switch (GetBackend()->GetConnector(gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL)->GetCurrentOrientation())
+				{
+					default:
+					case GAMESCOPE_PANEL_ORIENTATION_AUTO:
+					case GAMESCOPE_PANEL_ORIENTATION_0:
+						tx = *x;
+						ty = *y;
+						break;
+					case GAMESCOPE_PANEL_ORIENTATION_90:
+						tx = 1.0 - *y;
+						ty = *x;
+						break;
+					case GAMESCOPE_PANEL_ORIENTATION_180:
+						tx = 1.0 - *x;
+						ty = 1.0 - *y;
+						break;
+					case GAMESCOPE_PANEL_ORIENTATION_270:
+						tx = *y;
+						ty = 1.0 - *x;
+						break;
+				}
 			}
 		}
 		else
diff --git a/src/wlserver.hpp b/src/wlserver.hpp
index 0754ee5..bdf3b0b 100644
--- a/src/wlserver.hpp
+++ b/src/wlserver.hpp
@@ -277,6 +277,7 @@ extern gamescope::ConVar<bool> cv_touch_gestures;
 void wlserver_open_steam_menu( bool qam );
 extern void drm_set_orientation( struct drm_t *drm, bool isRotated);
 extern drm_t g_DRM;
+extern bool panelTypeChanged;
 uint32_t wlserver_make_new_xwayland_server();
 void wlserver_destroy_xwayland_server(gamescope_xwayland_server_t *server);
 
-- 
2.47.1


From 85c2c680332247440c74080af69a02ea6fda7675 Mon Sep 17 00:00:00 2001
From: Bouke Sybren Haarsma <boukehaarsma23@gmail.com>
Date: Tue, 28 May 2024 21:56:47 +0200
Subject: [PATCH 16/19] add closing bracket

---
 src/main.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/main.cpp b/src/main.cpp
index 14eb513..4493b92 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -463,6 +463,7 @@ static enum gamescope::GamescopeBackend parse_backend_name(const char *str)
 		fprintf( stderr, "gamescope: invalid value for --backend\n" );
 		exit(1);
 	}
+}
 
 std::vector<uint32_t> g_customRefreshRates;
 // eg: 60,60,90,110-120
-- 
2.47.1


From da32b357fc0b580fcefcd8453979df739cd86390 Mon Sep 17 00:00:00 2001
From: Bouke Sybren Haarsma <boukehaarsma23@gmail.com>
Date: Wed, 3 Jan 2024 17:03:04 +0100
Subject: [PATCH 17/19] remove hacky texture

This will use more hardware planes, causing some devices to composite yeilding lower framerates
---
 src/steamcompmgr.cpp | 62 ++++++++++++--------------------------------
 1 file changed, 17 insertions(+), 45 deletions(-)

diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index 11a7cad..0b0d17f 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -1621,7 +1621,7 @@ bool MouseCursor::getTexture()
 				{
 					pixels[i * image->width + j] = image->pixels[i * image->width + j];
 				}
-			} 
+			}
 			std::vector<uint32_t> resizeBuffer( nDesiredWidth * nDesiredHeight );
 			stbir_resize_uint8_srgb( (unsigned char *)pixels.data(),       image->width,  image->height,  0,
 									 (unsigned char *)resizeBuffer.data(), nDesiredWidth, nDesiredHeight, 0,
@@ -2316,7 +2316,7 @@ paint_all(bool async)
 					}
 				}
 			}
-			
+
 			int nOldLayerCount = frameInfo.layerCount;
 
 			uint32_t flags = 0;
@@ -2324,7 +2324,7 @@ paint_all(bool async)
 				flags |= PaintWindowFlag::BasePlane;
 			paint_window(w, w, &frameInfo, global_focus.cursor, flags);
 			update_touch_scaling( &frameInfo );
-			
+
 			// paint UI unless it's fully hidden, which it communicates to us through opacity=0
 			// we paint it to extract scaling coefficients above, then remove the layer if one was added
 			if ( w->opacity == TRANSLUCENT && bHasVideoUnderlay && nOldLayerCount < frameInfo.layerCount )
@@ -2337,7 +2337,7 @@ paint_all(bool async)
 				float opacityScale = g_bPendingFade
 					? 0.0f
 					: ((currentTime - fadeOutStartTime) / (float)g_FadeOutDuration);
-		
+
 				paint_cached_base_layer(g_HeldCommits[HELD_COMMIT_FADE], g_CachedPlanes[HELD_COMMIT_FADE], &frameInfo, 1.0f - opacityScale, false);
 				paint_window(w, w, &frameInfo, global_focus.cursor, PaintWindowFlag::BasePlane | PaintWindowFlag::FadeTarget | PaintWindowFlag::DrawBorders, opacityScale, override);
 			}
@@ -2411,34 +2411,6 @@ paint_all(bool async)
 		if ( overlay == global_focus.inputFocusWindow )
 			update_touch_scaling( &frameInfo );
 	}
-	else if ( !GetBackend()->UsesVulkanSwapchain() && GetBackend()->IsSessionBased() )
-	{
-		auto tex = vulkan_get_hacky_blank_texture();
-		if ( tex != nullptr )
-		{
-			// HACK! HACK HACK HACK
-			// To avoid stutter when toggling the overlay on 
-			int curLayer = frameInfo.layerCount++;
-
-			FrameInfo_t::Layer_t *layer = &frameInfo.layers[ curLayer ];
-
-
-			layer->scale.x = g_nOutputWidth == tex->width() ? 1.0f : tex->width() / (float)g_nOutputWidth;
-			layer->scale.y = g_nOutputHeight == tex->height() ? 1.0f : tex->height() / (float)g_nOutputHeight;
-			layer->offset.x = 0.0f;
-			layer->offset.y = 0.0f;
-			layer->opacity = 1.0f; // BLAH
-			layer->zpos = g_zposOverlay;
-			layer->applyColorMgmt = g_ColorMgmt.pending.enabled;
-
-			layer->colorspace = GAMESCOPE_APP_TEXTURE_COLORSPACE_LINEAR;
-			layer->ctm = nullptr;
-			layer->tex = tex;
-
-			layer->filter = GamescopeUpscaleFilter::NEAREST;
-			layer->blackBorder = true;
-		}
-	}
 
 	if (notification)
 	{
@@ -3043,7 +3015,7 @@ win_maybe_a_dropdown( steamcompmgr_win_t *w )
 	//
 	// TODO: Come back to me for original Age of Empires HD launcher.
 	// Does that use it? It wants blending!
-	// 
+	//
 	// Only do this if we have CONTROLPARENT right now. Some other apps, such as the
 	// Street Fighter V (310950) Splash Screen also use LAYERED and TOOLWINDOW, and we don't
 	// want that to be overlayed.
@@ -3058,12 +3030,12 @@ win_maybe_a_dropdown( steamcompmgr_win_t *w )
 
 	// Josh:
 	// The logic here is as follows. The window will be treated as a dropdown if:
-	// 
+	//
 	// If this window has a fixed position on the screen + static gravity:
 	//  - If the window has either skipPage or skipTaskbar
 	//    - If the window isn't a dialog, always treat it as a dropdown, as it's
 	//      probably meant to be some form of popup.
-	//    - If the window is a dialog 
+	//    - If the window is a dialog
 	// 		- If the window has transient for, disregard it, as it is trying to redirecting us elsewhere
 	//        ie. a settings menu dialog popup or something.
 	//      - If the window has both skip taskbar and pager, treat it as a dialog.
@@ -3155,7 +3127,7 @@ static bool is_good_override_candidate( steamcompmgr_win_t *override, steamcompm
 		return false;
 
 	return override != focus && override->GetGeometry().nX >= 0 && override->GetGeometry().nY >= 0;
-} 
+}
 
 static bool
 pick_primary_focus_and_override(focus_t *out, Window focusControlWindow, const std::vector<steamcompmgr_win_t*>& vecPossibleFocusWindows, bool globalFocus, const std::vector<uint32_t>& ctxFocusControlAppIDs)
@@ -3296,7 +3268,7 @@ found:;
 
 	if ( focus )
 	{
-		if ( window_has_commits( focus ) ) 
+		if ( window_has_commits( focus ) )
 			out->focusWindow = focus;
 		else
 			focus->outdatedInteractiveFocus = true;
@@ -3339,9 +3311,9 @@ found:;
 					override_focus = fake_override;
 					goto found2;
 				}
-			}	
+			}
 		}
-		
+
 		found2:;
 		resolveTransientOverrides( true );
 	}
@@ -4603,7 +4575,7 @@ finish_destroy_win(xwayland_ctx_t *ctx, Window id, bool gone)
 		{
 			if (gone)
 				finish_unmap_win (ctx, w);
-			
+
 			{
 				std::unique_lock lock( ctx->list_mutex );
 				*prev = w->xwayland().next;
@@ -4660,7 +4632,7 @@ destroy_win(xwayland_ctx_t *ctx, Window id, bool gone, bool fade)
 		global_focus.overrideWindow = nullptr;
 	if (x11_win(global_focus.fadeWindow) == id && gone)
 		global_focus.fadeWindow = nullptr;
-		
+
 	MakeFocusDirty();
 
 	finish_destroy_win(ctx, id, gone);
@@ -5284,7 +5256,7 @@ handle_property_notify(xwayland_ctx_t *ctx, XPropertyEvent *ev)
 		{
 			get_win_type(ctx, w);
 			MakeFocusDirty();
-		}		
+		}
 	}
 	if (ev->atom == ctx->atoms.sizeHintsAtom)
 	{
@@ -6187,7 +6159,7 @@ void handle_done_commits_xdg( bool vblank, uint64_t vblank_idx )
 			commits_before_their_time.push_back( entry );
 			continue;
 		}
-		
+
 		if (!entry.earliestPresentTime)
 		{
 			entry.earliestPresentTime = next_refresh_time;
@@ -7209,7 +7181,7 @@ void update_mode_atoms(xwayland_ctx_t *root_ctx, bool* needs_flush = nullptr)
 	}
 	XChangeProperty(root_ctx->dpy, root_ctx->root, root_ctx->atoms.gamescopeDisplayModeListExternal, XA_STRING, 8, PropModeReplace,
 		(unsigned char *)modes, strlen(modes) + 1 );
-	
+
 	uint32_t one = 1;
 	XChangeProperty(root_ctx->dpy, root_ctx->root, root_ctx->atoms.gamescopeDisplayIsExternal, XA_CARDINAL, 32, PropModeReplace,
 		(unsigned char *)&one, 1 );
@@ -8054,7 +8026,7 @@ void steamcompmgr_send_frame_done_to_focus_window()
 	{
 		wlserver_lock();
 		wlserver_send_frame_done( global_focus.focusWindow->xwayland().surface.main_surface , &now );
-		wlserver_unlock();		
+		wlserver_unlock();
 	}
 }
 
-- 
2.47.1


From 426fc5865a5a00339ab17bf006fddcca8a68675f Mon Sep 17 00:00:00 2001
From: Alesh Slovak <alesh@playtron.one>
Date: Thu, 26 Sep 2024 07:13:24 -0400
Subject: [PATCH 18/19] Revert "steamcompmgr: Move outdatedInteractiveFocus to
 window"

This reverts commit 299bc3410dcfd46da5e3c988354b60ed3a356900.
---
 src/steamcompmgr.cpp        | 39 +++++++++++++++++++++++--------------
 src/steamcompmgr_shared.hpp |  1 -
 2 files changed, 24 insertions(+), 16 deletions(-)

diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index 0b0d17f..d6aecec 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -3271,7 +3271,7 @@ found:;
 		if ( window_has_commits( focus ) )
 			out->focusWindow = focus;
 		else
-			focus->outdatedInteractiveFocus = true;
+			out->outdatedInteractiveFocus = true;
 
 		// Always update X's idea of focus, but still dirty
 		// the it being outdated so we can resolve that globally later.
@@ -6016,28 +6016,37 @@ bool handle_done_commit( steamcompmgr_win_t *w, xwayland_ctx_t *ctx, uint64_t co
 			// Window just got a new available commit, determine if that's worth a repaint
 
 			// If this is an overlay that we're presenting, repaint
-			if ( w == global_focus.overlayWindow && w->opacity != TRANSLUCENT )
+			if ( gameFocused )
 			{
-				hasRepaintNonBasePlane = true;
-			}
+				if ( w == global_focus.overlayWindow && w->opacity != TRANSLUCENT )
+				{
+					hasRepaintNonBasePlane = true;
+				}
 
-			if ( w == global_focus.notificationWindow && w->opacity != TRANSLUCENT )
-			{
-				hasRepaintNonBasePlane = true;
+				if ( w == global_focus.notificationWindow && w->opacity != TRANSLUCENT )
+				{
+					hasRepaintNonBasePlane = true;
+				}
 			}
-
-			// If this is an external overlay, repaint
-			if ( w == global_focus.externalOverlayWindow && w->opacity != TRANSLUCENT )
+			if ( ctx )
 			{
-				hasRepaintNonBasePlane = true;
+				if ( ctx->focus.outdatedInteractiveFocus )
+				{
+					MakeFocusDirty();
+					ctx->focus.outdatedInteractiveFocus = false;
+				}
 			}
-
-			if ( w->outdatedInteractiveFocus )
+			if ( global_focus.outdatedInteractiveFocus )
 			{
 				MakeFocusDirty();
-				w->outdatedInteractiveFocus = false;
-			}
+				global_focus.outdatedInteractiveFocus = false;
 
+				// If this is an external overlay, repaint
+				if ( w == global_focus.externalOverlayWindow && w->opacity != TRANSLUCENT )
+				{
+					hasRepaintNonBasePlane = true;
+				}
+			}
 			// If this is the main plane, repaint
 			if ( w == global_focus.focusWindow && !w->isSteamStreamingClient )
 			{
diff --git a/src/steamcompmgr_shared.hpp b/src/steamcompmgr_shared.hpp
index 095694e..e41fad9 100644
--- a/src/steamcompmgr_shared.hpp
+++ b/src/steamcompmgr_shared.hpp
@@ -125,7 +125,6 @@ struct steamcompmgr_win_t {
 	unsigned int requestedHeight = 0;
 	bool is_dialog = false;
 	bool maybe_a_dropdown = false;
-	bool outdatedInteractiveFocus = false;
 
 	bool hasHwndStyle = false;
 	uint32_t hwndStyle = 0;
-- 
2.47.1


From 09ce67db0d5806e0535b1d7d11e69a53ef21c517 Mon Sep 17 00:00:00 2001
From: Joshua Tam <297250+joshuatam@users.noreply.github.com>
Date: Fri, 6 Dec 2024 16:31:48 +0800
Subject: [PATCH 19/19] feature: add rotation shader for rotating output

---
 src/Backends/DRMBackend.cpp  |  26 +++++++-
 src/main.cpp                 |   6 ++
 src/main.hpp                 |   1 +
 src/meson.build              |   1 +
 src/rendervulkan.cpp         | 126 ++++++++++++++++++++++++++++++-----
 src/rendervulkan.hpp         |   6 +-
 src/shaders/cs_rotation.comp |  53 +++++++++++++++
 src/wlserver.cpp             |   5 ++
 8 files changed, 205 insertions(+), 19 deletions(-)
 create mode 100644 src/shaders/cs_rotation.comp

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 89b2802..4f859cb 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -1742,7 +1742,7 @@ LiftoffStateCacheEntry FrameInfoToLiftoffStateCacheEntry( struct drm_t *drm, con
 		uint64_t crtcW = srcWidth / frameInfo->layers[ i ].scale.x;
 		uint64_t crtcH = srcHeight / frameInfo->layers[ i ].scale.y;
 
-		if (g_bRotated)
+		if (g_bRotated && !g_bUseRotationShader)
 		{
 			int64_t imageH = frameInfo->layers[ i ].tex->contentHeight() / frameInfo->layers[ i ].scale.y;
 
@@ -2035,6 +2035,16 @@ namespace gamescope
 
 	void CDRMConnector::UpdateEffectiveOrientation( const drmModeModeInfo *pMode )
 	{
+		if (g_bUseRotationShader)
+		{
+			drm_log.infof("Using rotation shader");
+			if (g_DesiredInternalOrientation == GAMESCOPE_PANEL_ORIENTATION_270) {
+				m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_180;
+			} else {
+				m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_0;
+			}
+			return;
+		}
 
 		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_EXTERNAL && panelTypeChanged )
 			drm_log.infof("Display is internal faked as external");
@@ -3052,6 +3062,13 @@ bool drm_set_mode( struct drm_t *drm, const drmModeModeInfo *mode )
 		g_bRotated = false;
 		g_nOutputWidth = mode->hdisplay;
 		g_nOutputHeight = mode->vdisplay;
+
+		if (g_bUseRotationShader) {
+			g_bRotated = true;
+			g_nOutputWidth = mode->vdisplay;
+			g_nOutputHeight = mode->hdisplay;
+		}
+
 		break;
 	case GAMESCOPE_PANEL_ORIENTATION_90:
 	case GAMESCOPE_PANEL_ORIENTATION_270:
@@ -3311,6 +3328,11 @@ namespace gamescope
 
 			bNeedsFullComposite |= !!(g_uCompositeDebug & CompositeDebugFlag::Heatmap);
 
+			if (g_bUseRotationShader)
+			{
+				bNeedsFullComposite = true;
+			}
+
 			bool bDoComposite = true;
 			if ( !bNeedsFullComposite && !bWantsPartialComposite )
 			{
@@ -3401,7 +3423,7 @@ namespace gamescope
 			if ( bDefer && !!( g_uCompositeDebug & CompositeDebugFlag::Markers ) )
 				g_uCompositeDebug |= CompositeDebugFlag::Markers_Partial;
 
-			std::optional oCompositeResult = vulkan_composite( &compositeFrameInfo, nullptr, !bNeedsFullComposite );
+			std::optional oCompositeResult = vulkan_composite( &compositeFrameInfo, nullptr, !bNeedsFullComposite, nullptr, true, nullptr, g_bUseRotationShader );
 
 			m_bWasCompositing = true;
 
diff --git a/src/main.cpp b/src/main.cpp
index 4493b92..d90c14c 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -129,6 +129,7 @@ const struct option *gamescope_options = (struct option[]){
 	{ "composite-debug", no_argument, nullptr, 0 },
 	{ "disable-xres", no_argument, nullptr, 'x' },
 	{ "fade-out-duration", required_argument, nullptr, 0 },
+	{ "use-rotation-shader", required_argument, nullptr, 0 },
 	{ "force-orientation", required_argument, nullptr, 0 },
 	{ "force-external-orientation", required_argument, nullptr, 0 },
 	{ "force-panel-type", required_argument, nullptr, 0 },
@@ -194,6 +195,7 @@ const char usage[] =
 	"  --touch-gestures               enable touch gestures for Steam menus\n"
 	"  --xwayland-count               create N xwayland servers\n"
 	"  --prefer-vk-device             prefer Vulkan device for compositing (ex: 1002:7300)\n"
+	"  --use-rotation-shader		  use rotation shader for rotating the screen\n"
 	"  --force-orientation            rotate the internal display (left, right, normal, upsidedown)\n"
 	"  --force-external-orientation   rotate the external display (left, right, normal, upsidedown)\n"
 	"  --force-panel-type             force gamescope to treat the display as either internal or external\n"
@@ -356,6 +358,8 @@ static gamescope::GamescopeModeGeneration parse_gamescope_mode_generation( const
 	}
 }
 
+bool g_bUseRotationShader = false;
+
 GamescopePanelOrientation g_DesiredInternalOrientation = GAMESCOPE_PANEL_ORIENTATION_AUTO;
 static GamescopePanelOrientation force_orientation(const char *str)
 {
@@ -813,6 +817,8 @@ int main(int argc, char **argv)
 					gamescope::cv_touch_click_mode = (gamescope::TouchClickMode) atoi( optarg );
 				} else if (strcmp(opt_name, "generate-drm-mode") == 0) {
 					g_eGamescopeModeGeneration = parse_gamescope_mode_generation( optarg );
+				} else if (strcmp(opt_name, "use-rotation-shader") == 0) {
+					g_bUseRotationShader = true;
 				} else if (strcmp(opt_name, "force-orientation") == 0) {
 					g_DesiredInternalOrientation = force_orientation( optarg );
 				} else if (strcmp(opt_name, "force-external-orientation") == 0) {
diff --git a/src/main.hpp b/src/main.hpp
index 4e09e3b..584321d 100644
--- a/src/main.hpp
+++ b/src/main.hpp
@@ -22,6 +22,7 @@ extern bool g_bForceRelativeMouse;
 extern int g_nOutputRefresh; // mHz
 extern bool g_bOutputHDREnabled;
 extern bool g_bForceInternal;
+extern bool g_bUseRotationShader;
 
 extern bool g_bFullscreen;
 
diff --git a/src/meson.build b/src/meson.build
index 74fc033..d4ff3ea 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -70,6 +70,7 @@ shader_src = [
   'shaders/cs_nis.comp',
   'shaders/cs_nis_fp16.comp',
   'shaders/cs_rgb_to_nv12.comp',
+  'shaders/cs_rotation.comp',
 ]
 
 spirv_shaders = glsl_generator.process(shader_src)
diff --git a/src/rendervulkan.cpp b/src/rendervulkan.cpp
index 54d7608..10d6c78 100644
--- a/src/rendervulkan.cpp
+++ b/src/rendervulkan.cpp
@@ -48,6 +48,7 @@
 #include "cs_nis.h"
 #include "cs_nis_fp16.h"
 #include "cs_rgb_to_nv12.h"
+#include "cs_rotation.h"
 
 #define A_CPU
 #include "shaders/ffx_a.h"
@@ -898,6 +899,7 @@ bool CVulkanDevice::createShaders()
 		SHADER(NIS, cs_nis);
 	}
 	SHADER(RGB_TO_NV12, cs_rgb_to_nv12);
+	SHADER(ROTATION, cs_rotation);
 #undef SHADER
 
 	for (uint32_t i = 0; i < shaderInfos.size(); i++)
@@ -1128,6 +1130,7 @@ void CVulkanDevice::compileAllPipelines()
 	SHADER(EASU, 1, 1, 1);
 	SHADER(NIS, 1, 1, 1);
 	SHADER(RGB_TO_NV12, 1, 1, 1);
+	SHADER(ROTATION, k_nMaxLayers, k_nMaxYcbcrMask_ToPreCompile, k_nMaxBlurLayers);
 #undef SHADER
 
 	for (auto& info : pipelineInfos) {
@@ -3214,8 +3217,16 @@ static bool vulkan_make_output_images( VulkanOutput_t *pOutput )
 
 	uint32_t uDRMFormat = pOutput->uOutputFormat;
 
+	uint32_t l_nOutputWidth = g_nOutputWidth;
+	uint32_t l_nOutputHeight = g_nOutputHeight;
+
+	if (g_bUseRotationShader) {
+		l_nOutputWidth = g_nOutputHeight;
+		l_nOutputHeight = g_nOutputWidth;
+	}
+
 	pOutput->outputImages[0] = new CVulkanTexture();
-	bool bSuccess = pOutput->outputImages[0]->BInit( g_nOutputWidth, g_nOutputHeight, 1u, uDRMFormat, outputImageflags );
+	bool bSuccess = pOutput->outputImages[0]->BInit( l_nOutputWidth, l_nOutputHeight, 1u, uDRMFormat, outputImageflags );
 	if ( bSuccess != true )
 	{
 		vk_log.errorf( "failed to allocate buffer for KMS" );
@@ -3223,7 +3234,7 @@ static bool vulkan_make_output_images( VulkanOutput_t *pOutput )
 	}
 
 	pOutput->outputImages[1] = new CVulkanTexture();
-	bSuccess = pOutput->outputImages[1]->BInit( g_nOutputWidth, g_nOutputHeight, 1u, uDRMFormat, outputImageflags );
+	bSuccess = pOutput->outputImages[1]->BInit( l_nOutputWidth, l_nOutputHeight, 1u, uDRMFormat, outputImageflags );
 	if ( bSuccess != true )
 	{
 		vk_log.errorf( "failed to allocate buffer for KMS" );
@@ -3231,7 +3242,7 @@ static bool vulkan_make_output_images( VulkanOutput_t *pOutput )
 	}
 
 	pOutput->outputImages[2] = new CVulkanTexture();
-	bSuccess = pOutput->outputImages[2]->BInit( g_nOutputWidth, g_nOutputHeight, 1u, uDRMFormat, outputImageflags );
+	bSuccess = pOutput->outputImages[2]->BInit( l_nOutputWidth, l_nOutputHeight, 1u, uDRMFormat, outputImageflags );
 	if ( bSuccess != true )
 	{
 		vk_log.errorf( "failed to allocate buffer for KMS" );
@@ -3246,7 +3257,7 @@ static bool vulkan_make_output_images( VulkanOutput_t *pOutput )
 		uint32_t uPartialDRMFormat = pOutput->uOutputFormatOverlay;
 
 		pOutput->outputImagesPartialOverlay[0] = new CVulkanTexture();
-		bool bSuccess = pOutput->outputImagesPartialOverlay[0]->BInit( g_nOutputWidth, g_nOutputHeight, 1u, uPartialDRMFormat, outputImageflags, nullptr, 0, 0, pOutput->outputImages[0].get() );
+		bool bSuccess = pOutput->outputImagesPartialOverlay[0]->BInit( l_nOutputWidth, l_nOutputHeight, 1u, uPartialDRMFormat, outputImageflags, nullptr, 0, 0, pOutput->outputImages[0].get() );
 		if ( bSuccess != true )
 		{
 			vk_log.errorf( "failed to allocate buffer for KMS" );
@@ -3254,7 +3265,7 @@ static bool vulkan_make_output_images( VulkanOutput_t *pOutput )
 		}
 
 		pOutput->outputImagesPartialOverlay[1] = new CVulkanTexture();
-		bSuccess = pOutput->outputImagesPartialOverlay[1]->BInit( g_nOutputWidth, g_nOutputHeight, 1u, uPartialDRMFormat, outputImageflags, nullptr, 0, 0, pOutput->outputImages[1].get() );
+		bSuccess = pOutput->outputImagesPartialOverlay[1]->BInit( l_nOutputWidth, l_nOutputHeight, 1u, uPartialDRMFormat, outputImageflags, nullptr, 0, 0, pOutput->outputImages[1].get() );
 		if ( bSuccess != true )
 		{
 			vk_log.errorf( "failed to allocate buffer for KMS" );
@@ -3262,7 +3273,7 @@ static bool vulkan_make_output_images( VulkanOutput_t *pOutput )
 		}
 
 		pOutput->outputImagesPartialOverlay[2] = new CVulkanTexture();
-		bSuccess = pOutput->outputImagesPartialOverlay[2]->BInit( g_nOutputWidth, g_nOutputHeight, 1u, uPartialDRMFormat, outputImageflags, nullptr, 0, 0, pOutput->outputImages[2].get() );
+		bSuccess = pOutput->outputImagesPartialOverlay[2]->BInit( l_nOutputWidth, l_nOutputHeight, 1u, uPartialDRMFormat, outputImageflags, nullptr, 0, 0, pOutput->outputImages[2].get() );
 		if ( bSuccess != true )
 		{
 			vk_log.errorf( "failed to allocate buffer for KMS" );
@@ -3392,6 +3403,28 @@ static void update_tmp_images( uint32_t width, uint32_t height )
 	}
 }
 
+static void update_rotated_images( uint32_t width, uint32_t height )
+{
+	if ( g_output.rotatedOutput != nullptr
+			&& width == g_output.rotatedOutput->width()
+			&& height == g_output.rotatedOutput->height() )
+	{
+		return;
+	}
+
+	CVulkanTexture::createFlags createFlags;
+	createFlags.bSampled = true;
+	createFlags.bStorage = true;
+
+	g_output.rotatedOutput = new CVulkanTexture();
+	bool bSuccess = g_output.rotatedOutput->BInit( width, height, 1u, DRM_FORMAT_ARGB8888, createFlags, nullptr );
+
+	if ( !bSuccess )
+	{
+		vk_log.errorf( "failed to create rotated output" );
+		return;
+	}
+}
 
 static bool init_nis_data()
 {
@@ -3856,7 +3889,7 @@ std::optional<uint64_t> vulkan_screenshot( const struct FrameInfo_t *frameInfo,
 extern std::string g_reshade_effect;
 extern uint32_t g_reshade_technique_idx;
 
-std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamescope::Rc<CVulkanTexture> pPipewireTexture, bool partial, gamescope::Rc<CVulkanTexture> pOutputOverride, bool increment, std::unique_ptr<CVulkanCmdBuffer> pInCommandBuffer )
+std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamescope::Rc<CVulkanTexture> pPipewireTexture, bool partial, gamescope::Rc<CVulkanTexture> pOutputOverride, bool increment, std::unique_ptr<CVulkanCmdBuffer> pInCommandBuffer, bool applyRotation )
 {
 	EOTF outputTF = frameInfo->outputEncodingEOTF;
 	if (!frameInfo->applyOutputColorMgmt)
@@ -3928,7 +3961,15 @@ std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamesco
 		cmdBuffer->setTextureSrgb(0, true);
 		cmdBuffer->setSamplerUnnormalized(0, false);
 		cmdBuffer->setSamplerNearest(0, false);
-		cmdBuffer->bindTarget(compositeImage);
+
+		if (applyRotation) {
+			// Make a rotatedOutput with normal dimensions
+			update_rotated_images(currentOutputWidth, currentOutputHeight); // 2560x1600
+			cmdBuffer->bindTarget(g_output.rotatedOutput);
+		} else {
+			cmdBuffer->bindTarget(compositeImage);
+		}
+
 		cmdBuffer->uploadConstants<RcasPushData_t>(frameInfo, g_upscaleFilterSharpness / 10.0f);
 
 		cmdBuffer->dispatch(div_roundup(currentOutputWidth, pixelsPerGroup), div_roundup(currentOutputHeight, pixelsPerGroup));
@@ -3971,7 +4012,15 @@ std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamesco
 
 		cmdBuffer->bindPipeline( g_device.pipeline(SHADER_TYPE_BLIT, nisFrameInfo.layerCount, nisFrameInfo.ycbcrMask(), 0u, nisFrameInfo.colorspaceMask(), outputTF ));
 		bind_all_layers(cmdBuffer.get(), &nisFrameInfo);
-		cmdBuffer->bindTarget(compositeImage);
+
+		if (applyRotation) {
+			// Make a rotatedOutput with normal dimensions
+			update_rotated_images(currentOutputWidth, currentOutputHeight); // 2560x1600
+			cmdBuffer->bindTarget(g_output.rotatedOutput);
+		} else {
+			cmdBuffer->bindTarget(compositeImage);
+		}
+
 		cmdBuffer->uploadConstants<BlitPushData_t>(&nisFrameInfo);
 
 		int pixelsPerGroup = 8;
@@ -4009,7 +4058,15 @@ std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamesco
 		type = frameInfo->blurLayer0 == BLUR_MODE_COND ? SHADER_TYPE_BLUR_COND : SHADER_TYPE_BLUR;
 		cmdBuffer->bindPipeline(g_device.pipeline(type, frameInfo->layerCount, frameInfo->ycbcrMask(), blur_layer_count, frameInfo->colorspaceMask(), outputTF ));
 		bind_all_layers(cmdBuffer.get(), frameInfo);
-		cmdBuffer->bindTarget(compositeImage);
+
+		if (applyRotation) {
+			// Make a rotatedOutput with normal dimensions
+			update_rotated_images(currentOutputWidth, currentOutputHeight); // 2560x1600
+			cmdBuffer->bindTarget(g_output.rotatedOutput);
+		} else {
+			cmdBuffer->bindTarget(compositeImage);
+		}
+
 		cmdBuffer->bindTexture(VKR_BLUR_EXTRA_SLOT, g_output.tmpOutput);
 		cmdBuffer->setTextureSrgb(VKR_BLUR_EXTRA_SLOT, !useSrgbView); // Inverted because it chooses whether to view as linear (sRGB view) or sRGB (raw view). It's horrible. I need to change it.
 		cmdBuffer->setSamplerUnnormalized(VKR_BLUR_EXTRA_SLOT, true);
@@ -4019,14 +4076,51 @@ std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamesco
 	}
 	else
 	{
-		cmdBuffer->bindPipeline( g_device.pipeline(SHADER_TYPE_BLIT, frameInfo->layerCount, frameInfo->ycbcrMask(), 0u, frameInfo->colorspaceMask(), outputTF ));
-		bind_all_layers(cmdBuffer.get(), frameInfo);
-		cmdBuffer->bindTarget(compositeImage);
-		cmdBuffer->uploadConstants<BlitPushData_t>(frameInfo);
+		if (applyRotation) {
+			cmdBuffer->bindPipeline( g_device.pipeline(SHADER_TYPE_ROTATION, frameInfo->layerCount, frameInfo->ycbcrMask(), 0u, frameInfo->colorspaceMask(), outputTF ));
+			bind_all_layers(cmdBuffer.get(), frameInfo);
+			cmdBuffer->bindTarget(compositeImage);
+			cmdBuffer->uploadConstants<BlitPushData_t>(frameInfo);
 
-		const int pixelsPerGroup = 8;
+			const int pixelsPerGroup = 8;
 
-		cmdBuffer->dispatch(div_roundup(currentOutputWidth, pixelsPerGroup), div_roundup(currentOutputHeight, pixelsPerGroup));
+			cmdBuffer->dispatch(div_roundup(currentOutputWidth, pixelsPerGroup), div_roundup(currentOutputHeight, pixelsPerGroup));
+		} else {
+			cmdBuffer->bindPipeline( g_device.pipeline(SHADER_TYPE_BLIT, frameInfo->layerCount, frameInfo->ycbcrMask(), 0u, frameInfo->colorspaceMask(), outputTF ));
+			bind_all_layers(cmdBuffer.get(), frameInfo);
+			cmdBuffer->bindTarget(compositeImage);
+			cmdBuffer->uploadConstants<BlitPushData_t>(frameInfo);
+
+			const int pixelsPerGroup = 8;
+
+			cmdBuffer->dispatch(div_roundup(currentOutputWidth, pixelsPerGroup), div_roundup(currentOutputHeight, pixelsPerGroup));
+		}
+	}
+
+	if (applyRotation)
+	{
+		if (g_output.rotatedOutput != nullptr) {
+			// Rotate the final output
+			// TODO: may need rework with another rotation shader for blur, fsr and nis
+			cmdBuffer->bindPipeline( g_device.pipeline(SHADER_TYPE_ROTATION, frameInfo->layerCount, frameInfo->ycbcrMask(), 0u, frameInfo->colorspaceMask(), outputTF));
+			bind_all_layers(cmdBuffer.get(), frameInfo);
+
+			// if (frameInfo->blurLayer0) {
+			// 	bool useSrgbView = frameInfo->layers[0].colorspace == GAMESCOPE_APP_TEXTURE_COLORSPACE_LINEAR;
+			//
+			// 	cmdBuffer->bindTexture(VKR_BLUR_EXTRA_SLOT, g_output.rotatedOutput);
+			// 	cmdBuffer->setTextureSrgb(VKR_BLUR_EXTRA_SLOT, !useSrgbView);
+			// 	cmdBuffer->setSamplerUnnormalized(VKR_BLUR_EXTRA_SLOT, true);
+			// 	cmdBuffer->setSamplerNearest(VKR_BLUR_EXTRA_SLOT, false);
+			// }
+
+			cmdBuffer->bindTarget(compositeImage);
+			cmdBuffer->uploadConstants<BlitPushData_t>(frameInfo);
+
+			const int pixelsPerGroup = 8;
+
+			cmdBuffer->dispatch(div_roundup(currentOutputWidth, pixelsPerGroup), div_roundup(currentOutputHeight, pixelsPerGroup));
+		}
 	}
 
 	if ( pPipewireTexture != nullptr )
diff --git a/src/rendervulkan.hpp b/src/rendervulkan.hpp
index b967e84..155be60 100644
--- a/src/rendervulkan.hpp
+++ b/src/rendervulkan.hpp
@@ -390,7 +390,7 @@ gamescope::OwningRc<CVulkanTexture> vulkan_create_texture_from_dmabuf( struct wl
 gamescope::OwningRc<CVulkanTexture> vulkan_create_texture_from_bits( uint32_t width, uint32_t height, uint32_t contentWidth, uint32_t contentHeight, uint32_t drmFormat, CVulkanTexture::createFlags texCreateFlags, void *bits );
 gamescope::OwningRc<CVulkanTexture> vulkan_create_texture_from_wlr_buffer( struct wlr_buffer *buf, gamescope::OwningRc<gamescope::IBackendFb> pBackendFb );
 
-std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamescope::Rc<CVulkanTexture> pScreenshotTexture, bool partial, gamescope::Rc<CVulkanTexture> pOutputOverride = nullptr, bool increment = true, std::unique_ptr<CVulkanCmdBuffer> pInCommandBuffer = nullptr );
+std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamescope::Rc<CVulkanTexture> pScreenshotTexture, bool partial, gamescope::Rc<CVulkanTexture> pOutputOverride = nullptr, bool increment = true, std::unique_ptr<CVulkanCmdBuffer> pInCommandBuffer = nullptr, bool applyRotation = false );
 void vulkan_wait( uint64_t ulSeqNo, bool bReset );
 gamescope::Rc<CVulkanTexture> vulkan_get_last_output_image( bool partial, bool defer );
 gamescope::Rc<CVulkanTexture> vulkan_acquire_screenshot_texture(uint32_t width, uint32_t height, bool exportable, uint32_t drmFormat, EStreamColorspace colorspace = k_EStreamColorspace_Unknown);
@@ -519,6 +519,9 @@ struct VulkanOutput_t
 	// NIS
 	gamescope::OwningRc<CVulkanTexture> nisScalerImage;
 	gamescope::OwningRc<CVulkanTexture> nisUsmImage;
+
+	// Rotated
+	gamescope::OwningRc<CVulkanTexture> rotatedOutput;
 };
 
 
@@ -531,6 +534,7 @@ enum ShaderType {
 	SHADER_TYPE_RCAS,
 	SHADER_TYPE_NIS,
 	SHADER_TYPE_RGB_TO_NV12,
+	SHADER_TYPE_ROTATION,
 
 	SHADER_TYPE_COUNT
 };
diff --git a/src/shaders/cs_rotation.comp b/src/shaders/cs_rotation.comp
new file mode 100644
index 0000000..1a47fd5
--- /dev/null
+++ b/src/shaders/cs_rotation.comp
@@ -0,0 +1,53 @@
+#version 450
+
+#extension GL_GOOGLE_include_directive : require
+#extension GL_EXT_scalar_block_layout : require
+
+#include "descriptor_set.h"
+
+layout(
+    local_size_x = 8,
+    local_size_y = 8,
+    local_size_z = 1) in;
+
+#include "blit_push_data.h"
+#include "composite.h"
+
+vec4 sampleLayer(uint layerIdx, vec2 uv) {
+    if ((c_ycbcrMask & (1 << layerIdx)) != 0)
+        return sampleLayer(s_ycbcr_samplers[layerIdx], layerIdx, uv, false);
+    return sampleLayer(s_samplers[layerIdx], layerIdx, uv, true);
+}
+
+void main() {
+    uvec2 coord = uvec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
+    uvec2 outSize = imageSize(dst);
+    float outWidth = outSize.y;
+    float outHeight = outSize.x;
+
+    vec2 uv = vec2(coord);
+    vec4 outputValue = vec4(255.0f);
+
+    if (c_layerCount > 0) {
+        outputValue = sampleLayer(0, uv) * u_opacity[0];
+    }
+
+    for (int i = 1; i < c_layerCount; i++) {
+        vec4 layerColor = sampleLayer(i, uv);
+        // wl_surfaces come with premultiplied alpha, so that's them being
+        // premultiplied by layerColor.a.
+        // We need to then multiply that by the layer's opacity to get to our
+        // final premultiplied state.
+        // For the other side of things, we need to multiply by (1.0f - (layerColor.a * opacity))
+        float opacity = u_opacity[i];
+        float layerAlpha = opacity * layerColor.a;
+        outputValue = layerColor * opacity + outputValue * (1.0f - layerAlpha);
+    }
+
+    outputValue.rgb = encodeOutputColor(outputValue.rgb);
+
+    // Rotate the pixel coordinates counter-clockwise by 90 degrees
+    ivec2 rotatedCoord = ivec2(coord.y, outWidth - coord.x - 1);
+
+    imageStore(dst, rotatedCoord, outputValue);
+}
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index 7adf7db..346ff57 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -2646,6 +2646,11 @@ static void apply_touchscreen_orientation(double *x, double *y )
         }
     }
 
+	if (g_bUseRotationShader) {
+		tx = 1.0 - *y;
+		ty = *x;
+	}
+
     *x = tx;
     *y = ty;
 }
-- 
2.47.1

